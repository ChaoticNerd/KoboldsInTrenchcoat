// Lab6_Interrupts.c
// Starter file for CECS346 Lab 6
// By Dr. Min He
// 3/14/2024

#include "tm4c123gh6pm.h"
#include <stdint.h> // C99 data types

// 1. Pre-processor Directives Section
// Constant declarations to access port registers using 
// symbolic names instead of addresses

// TODO: define bit addresses for the three LEDs connected to PORTF
// need ports 0-3, SW2 as port0 and LED as port1-3
// idk which symbolic name defines specifically those ports???
#define LED_ADR        0x40025038
#define SW2_ADR        0x40025004
#define PF_UNLOCK      0x4C4F434B
#define PORTF_INT_PRI  4U
#define PORTF_PRI_BITS 0x00E00000
#define LED        (*((volatile uint32_t *)LED_ADR))   
#define SW2        (*((volatile uint32_t *)SW2_ADR))   
	
// TODO: Define the three LED bit positions
// is it right to left or am i crazy
#define SW2_MASK        0x01
#define RED  			0x02
#define BLUE 			0x04
#define GREEN			0x08
#define RGB             0x0E
#define PF_3_0          0x0F

// TODO: define constants used in this project.
// what is u....
// ok apparently u means unsigned int
// it's the usual 1/16000000 (16 million comes from 16MHz)
// For 0.5s, 16000000*0.5 = 80000000
#define HALF_S 							80000000U          // Assume the system clock is 16MHz.
																				// define number of clock cycles to generate 0.5s time interval.
                                        // A U follows a constant indicate this is an unsigned number
// ok i havent checked this yet but it should be in the slides for interrupt
// 0100 0000 0000 0000 0000 0000 0000 0000 = 0x40000000
#define NVIC_EN0_PORTF		  0x40000000  // bit position for PORTF interrupt in NVIC_EN0_R register.


// Function Prototypes (external functions from startup.s)
extern void DisableInterrupts(void); // Disable interrupts
extern void EnableInterrupts(void);  // Enable interrupts
extern void WaitForInterrupt(void);  // Go to low power mode while waiting for the next interrupt

// Function Prototypes
// Initialize rising edge triggered interrupt for PF0 (SW2) and three LEDs on Port F
void Switch_LED_Init(void);  

// Initialize SysTick timer with interrupt enabled.
// Parameter "period" specifies number of counts for the time 
// period generated by systick timer.
void SysTick_Init(uint32_t period);      

// global variable visible in Watch and Memory window of debugger:
// used for the purpose of practicing debug: use watch window and memory window 
// to keep track of varaible values and memory contents.
// This variable helps keeping track of number of button presses: 
// it increments once per button release.
volatile uint32_t RisingEdges = 0;

// keep track of the current active LED 
volatile uint8_t curr_led = RED;

int main(void){
	DisableInterrupts();
  Switch_LED_Init();
	SysTick_Init(HALF_S);
	EnableInterrupts();
	
	// initialize current active LED to be red
	LED = RED;
	curr_led = RED;
	
  while(1){
		WaitForInterrupt();

    // if button is pressed, call GPIOPortF_Handler
    // not pressed == 0x00 (positive logic button)
    if(SW2&SW2_MASK){
      GPIOPortF_Handler();
    }
  }
}


// TODO: Initialize rising edge triggered interrupt for PF0 (SW2) and three LEDs on Port F
void Switch_LED_Init(void) {
	SYSCTL_RCGCGPIO_R |= SYSCTL_RCGCGPIO_R5;     	// activate F clock
	while ((SYSCTL_RCGCGPIO_R&SYSCTL_RCGCGPIO_R5)!=SYSCTL_RCGCGPIO_R5){} // wait for the clock to be ready
  // Normal Init Stuff
  GPIO_PORTF_LOCK_R = PF_UNLOCK // unlock PF0
  GPIO_PORTF_DIR_R &= ~SW2_MASK;    // (c) make PF0 in (built-in button), clear to make in
  GPIO_PORTF_DIR_R |= RGB; // make PF3-1 out (LEDs)
  GPIO_PORTF_AFSEL_R &= ~0x0000FFFF;  //     disable alt funct on PF3-0
  GPIO_PORTF_DEN_R |= PF_3_0;     //     enable digital I/O on PF3-0
  GPIO_PORTF_PCTL_R &= ~PF_3_0;  // configure PF3-0 as GPIO
  GPIO_PORTF_AMSEL_R &= ~PF_3_0;       //     disable analog functionality on PF
  GPIO_PORTF_PUR_R |= PF_3_0;     //     enable weak pull-up on PF4

  // Interrupt Init Stuff
  GPIO_PORTF_IS_R &= ~SW2_MASK;     // (d) set PF0 to 0 to make it edge sensitive
  GPIO_PORTF_IBE_R &= ~SW2_MASK;    //  set PF0 to 0 to state it's only sensitive to 1 edge
  GPIO_PORTF_IEV_R |= SW2_MASK;    //  set PF0 to 1 to make it rising edge sensitive
  // slides say use only = on ICR, but edge trigger lab project uses |=?
  GPIO_PORTF_ICR_R |= SW2_MASK;     // (e) clear flag0, note: writing 1 will clear bits in RIS
  // more on RIS: it flags at the port bit where the interrupt occurs, so
  // interrupting on PF0 flags RIS bit 0
  // 1 means an interrupt has occured
  // we are using ICR on bit 0 to clear that interrupt on initialization
  GPIO_PORTF_IM_R |= SW2_MASK;      // (f) arm interrupt on PF0
  // sends interrupt signal to controller at corresponding bit

  // set PF0 to priority 4 interrupt
  // priority 4 = 100 0 0000 = 0x80
  // 0xFF1FFFFF is to clear bits 23-21 that determine PF priority
  // NVIC_PRI7_R = (NVIC_PRI7_R&0xFF1FFFFF)|0x00800000; // (g) PORTF Interrupt priority bits: 23-21, priority set to 5
  // can use the above OR below line to set the priority
  // this line does the same thing except it shifts the priority bits from 0 to position 21
  NVIC_PRI7_R = (NVIC_PRI7_R&~PORTF_PRI_BITS)|PORTF_INT_PRI<<21; // (g) PORTF Interrupt priority bits: 23-21, priority set to 5
  NVIC_EN0_R |= 0x40000000;     // (h) PORTF interrupt number is 30, enable bit 30 in NVIC.     

}
// Implement Switch_LED_Init() to initialize the three onboard LEDs and rising edge
// triggered interrupt for PF0 (SW2) using friendly coding.

// TODO: Initialize SysTick timer with interrupt enabled.
// Parameter "period" specifies number of counts for the time 
void SysTick_Init(uint32_t period) {
  // we should take the systick init from prev labs
  NVIC_ST_CTRL_R = 0; // clear to disable systick while setting up
  // combine init AND delay?
  NVIC_ST_RELOAD_R = period - 1; // set reload to .5s
  NVIC_ST_CURRENT_R = 0; // clear current
  // priority is 1, aka 0010
  NVIC_SYS_PRI3_R = (NVIC_SYS_PRI3_R & 0x1FFFFFFF) | 0x20000000;
  NVIC_ST_CTRL_R = 0x07; // clk_src = 1, inten = 1, en = 1
  EnableInterrupts();
  // add interrupt stuff
}

// Toggles through LED colors on port F (onboard LED) **DONE
void GPIOPortF_Handler(void) {
	// simple solution to take care of button debounce: 20ms to 30ms delay
  for (uint32_t i=0;i<160000;i++) {}

  // Round-robin LED Red --> Blue --> Green
  if (curr_led == GREEN) {
	curr_led = (curr_led >> 2); // why cant this one just be red? it can. but it can also be a shift.
  } else {
  curr_led = (curr_led << 1);
  } 
    RisingEdges += 1;
}

// TODO: ISR that Handles SysTick generated interrupts. 
// When timer interrupt triggers, do what's necessary then toggle the current LED
void SysTick_Handler(void) {
  // Flash LED
  //GPIO_PORTF_DATA_R ^= 0x04 //Toggle PF2
  curr_led ^= curr_led; // XORed
  // i think it's curr_led? LED gives us the piort data, no?
  // we use LED for the other labs tho... thinkin //well isnt it based on what we defined it as??? 
}
