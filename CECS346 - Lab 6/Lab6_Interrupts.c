// Lab6_Interrupts.c
// Starter file for CECS346 Lab 6
// By Dr. Min He
// 3/14/2024

#include "tm4c123gh6pm.h"
#include <stdint.h> // C99 data types

// 1. Pre-processor Directives Section
// Constant declarations to access port registers using 
// symbolic names instead of addresses

// TODO: define bit addresses for the three LEDs connected to PORTF
// need ports 0-3, SW2 as port0 and LED as port1-3
// idk which symbolic name defines specifically those ports???
#define LED_ADR        0x40025038
#define SW2_ADR        0x40025004
#define PF_UNLOCK      0x4C4F434B
#define PORTF_INT_PRI  4U
#define PORTF_PRI_BITS 0x00E00000
#define LED        (*((volatile uint32_t *)LED_ADR))   
#define SW2        (*((volatile uint32_t *)SW2_ADR))   
	
// TODO: Define the three LED bit positions
// is it right to left or am i crazy
#define SW2_MASK        0x01
#define RED  			0x02
#define BLUE 			0x04
#define GREEN			0x08
#define RGB             0x0E
#define PF_3_0          0x0F
// is sw 0x01?

// TODO: define constants used in this project.
// what is u....
// ok apparently u means unsigned int so we have to set this to 5? if it is 10 ms wait each
#define HALF_S 							0U          // Assume the system clock is 16MHz.
																				// define number of clock cycles to generate 0.5s time interval.
                                        // A U follows a constant indicate this is an unsigned number
#define NVIC_EN0_PORTF		  0x00000000  // bit position for PORTF interrupt in NVIC_EN0_R register.


// Function Prototypes (external functions from startup.s)
extern void DisableInterrupts(void); // Disable interrupts
extern void EnableInterrupts(void);  // Enable interrupts
extern void WaitForInterrupt(void);  // Go to low power mode while waiting for the next interrupt

// Function Prototypes
// Initialize rising edge triggered interrupt for PF0 (SW2) and three LEDs on Port F
void Switch_LED_Init(void);  

// Initialize SysTick timer with interrupt enabled.
// Parameter "period" specifies number of counts for the time 
// period generated by systick timer.
void SysTick_Init(uint32_t period);      

// global variable visible in Watch and Memory window of debugger:
// used for the purpose of practicing debug: use watch window and memory window 
// to keep track of varaible values and memory contents.
// This variable helps keeping track of number of button presses: 
// it increments once per button release.
volatile uint32_t RisingEdges = 0;

// keep track of the current active LED
volatile uint8_t curr_led = RED;

int main(void){
	DisableInterrupts();
  Switch_LED_Init();
	SysTick_Init(HALF_S);
	EnableInterrupts();
	
	// initialize current active LED to be red
	LED = RED;
	curr_led = RED;
	
  while(1){
		WaitForInterrupt();
  }
}


// TODO: Initialize rising edge triggered interrupt for PF0 (SW2) and three LEDs on Port F
void Switch_LED_Init(void) {
	SYSCTL_RCGCGPIO_R |= SYSCTL_RCGCGPIO_R5;     	// activate F clock
	while ((SYSCTL_RCGCGPIO_R&SYSCTL_RCGCGPIO_R5)!=SYSCTL_RCGCGPIO_R5){} // wait for the clock to be ready
  // unlock PF0 and choose alternate function?
  // oh its a normal init
  // kinda
  GPIO_PORTF_LOCK_R = PF_UNLOCK // unlock PF0
  GPIO_PORTF_DIR_R &= ~SW2_MASK;    // (c) make PF0 in (built-in button), clear to make in
  GPIO_PORTF_DIR_R |= RGB; // make PF3-1 out (LEDs)
  GPIO_PORTF_AFSEL_R &= ~0x0000FFFF;  //     disable alt funct on PF3-0
  GPIO_PORTF_DEN_R |= PF_3_0;     //     enable digital I/O on PF3-0
  GPIO_PORTF_PCTL_R &= ~PF_3_0;  // configure PF3-0 as GPIO
  GPIO_PORTF_AMSEL_R &= ~PF_3_0;       //     disable analog functionality on PF
  GPIO_PORTF_PUR_R |= PF_3_0;     //     enable weak pull-up on PF4
  GPIO_PORTF_IS_R &= ~SW2_MASK;     // (d) PF0 is edge-sensitive (value 0)
  GPIO_PORTF_IBE_R &= ~SW2_MASK;    //     PF0 is not both edges (value 0)
  GPIO_PORTF_IEV_R |= SW2_MASK;    //     PF4 rising edge event: 1
  // slides say use only = on ICR, but edge trigger lab project uses |=?
  GPIO_PORTF_ICR_R |= SW2_MASK;     // (e) clear flag4, note: writing 1 will clear bits in RIS
  // more on RIS: it flags at the port bit where the interrupt occurs, so
  // interrupting on PF0 flags RIS bit 0
  // 1 means an interrupt has occured
  // we are using ICR on bit 0 to clear that interrupt on initialization
  GPIO_PORTF_IM_R |= SW2_MASK;      // (f) arm interrupt on PF0
  // sends interrupt signal to controller at corresponding bit

  // set PF0 to priority 4 interrupt
  // priority 4 = 100 0 0000 = 0x80
  // 0xFF1FFFFF is to clear bits 23-21 that determine PF priority
  // NVIC_PRI7_R = (NVIC_PRI7_R&0xFF1FFFFF)|0x00800000; // (g) PORTF Interrupt priority bits: 23-21, priority set to 5
  // can use the above OR below line to set the priority
  // this line does the same thing except it shifts the priority bits from 0 to position 21
  NVIC_PRI7_R = (NVIC_PRI7_R&~PORTF_PRI_BITS)|PORTF_INT_PRI<<21; // (g) PORTF Interrupt priority bits: 23-21, priority set to 5
  NVIC_EN0_R |= 0x40000000;     // (h) PORTF interrupt number is 30, enable bit 30 in NVIC.     

}
// Implement Switch_LED_Init() to initialize the three onboard LEDs and rising edge
// triggered interrupt for PF0 (SW2) using friendly coding.

// TODO: Initialize SysTick timer with interrupt enabled.
// Parameter "period" specifies number of counts for the time 
void SysTick_Init(uint32_t period) {
}

// TODO: ISR that Handles GPIO Port F interrupts. 
// When Port F interrupt triggers, do what's necessary then increment global variable RisingEdges
void GPIOPortF_Handler(void) {
	// simple solution to take care of button debounce: 20ms to 30ms delay
  for (uint32_t i=0;i<160000;i++) {}	
  // do the things idk
  // OH THIS IS BUTTON AND LED CHANGE I SEE
  // SYSTICK AND INTERRUPT PRIORITY ARE DIFFERENT
  RisingEdges += 1;
}

// TODO: ISR that Handles SysTick generated interrupts. 
// When timer interrupt triggers, do what's necessary then toggle the current LED
void SysTick_Handler(void) {
}
